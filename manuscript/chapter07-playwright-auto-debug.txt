# Auto-Debugging E2E Tests with Claude Code

E2E tests fail. That's normal. What matters is how quickly you get them passing again. With Claude Code, debugging is a conversation, not a detective investigation.

## The Old Way vs The Vibe Coding Way

**Traditional E2E debugging:**
1. Test fails
2. Read cryptic error message
3. Google Playwright docs
4. Add `console.log()` statements
5. Re-run test
6. Try different selector
7. Re-run test
8. Add arbitrary timeout
9. Re-run test
10. Give up after 2 hours

**Vibe coding E2E debugging:**
1. Test fails
2. Copy error to Claude Code
3. Claude fixes it
4. Re-run test
5. Done in 5 minutes

## When Tests Fail: The Workflow

### Step 1: Run the Test

{lang=bash}
```
npx playwright test
```

### Step 2: Get the Error

Test output shows:

```
✓ auth/login.spec.ts:5:7 › user can sign in
✗ tasks/create.spec.ts:10:7 › user creates task (5.2s)

Error: Timeout 30000ms exceeded waiting for getByRole('button', { name: 'Create' })
```

### Step 3: Tell Claude Code

**You:** "The 'create task' test is failing. Here's the error:

```
Error: Timeout 30000ms exceeded waiting for getByRole('button', { name: 'Create' })
```
"

### Step 4: Claude Debugs and Fixes

**Claude Code:**
```
The button selector is timing out. Let me check the test and your current UI.

Looking at your components, I see the button text changed from "Create" to "Create Task" in the last commit.

I'll update the test:

[Shows the fix]

Also, I'll add a wait for the form to be fully loaded before clicking:

[Shows the additional fix]

Try running the test again.
```

### Step 5: Verify

{lang=bash}
```
npx playwright test tasks/create.spec.ts
```

Test passes → Done.

Test still fails → Go back to Step 2.

## Common Failures and How Claude Fixes Them

### Failure 1: Element Not Found

**Error:**
```
Error: locator.click: Target closed
```

**You:** "Test failed with 'Target closed'. What does that mean?"

**Claude Code:**
```
This usually means the page navigated away before the action completed.

Looking at your test, you're clicking "Create" which triggers a navigation,
but the test tries to interact with the page before the navigation finishes.

I'll add a wait for the navigation:

await page.getByRole('button', { name: 'Create' }).click();
await page.waitForURL('/dashboard');  // Wait for navigation

Then we can assert on the new page.
```

### Failure 2: Flaky Test (Sometimes Passes, Sometimes Fails)

**You:** "This test passes locally but fails in CI sometimes."

**Claude Code:**
```
Flaky tests are usually race conditions. Let me analyze your test.

I see you're clicking "Load Tasks" and immediately checking if tasks appear.
The API call hasn't returned yet in CI (slower machine).

I'll add a proper wait for the API response:

await page.getByRole('button', { name: 'Load Tasks' }).click();

// Wait for API call to complete
await page.waitForResponse(resp =>
  resp.url().includes('/api/tasks') &&
  resp.status() === 200
);

// Now assert
await expect(page.getByText('Task 1')).toBeVisible();

This eliminates the race condition.
```

### Failure 3: Test Passes Locally, Fails in CI

**You:** "All tests pass on my machine but failing in GitHub Actions."

**Claude Code:**
```
Let me check the CI logs...

I see the error is "ECONNREFUSED" - the dev server isn't starting in CI.

Looking at your playwright.config.ts, the webServer timeout is too short.

I'll update the config:

webServer: {
  command: 'npm run dev',
  url: 'http://localhost:3000',
  timeout: 120 * 1000,  // Increased from 60s to 120s
  reuseExistingServer: !process.env.CI,
},

CI machines are slower, so they need more time to start the server.
```

### Failure 4: Authentication Issues

**You:** "Test can't log in. Getting '401 Unauthorized'."

**Claude Code:**
```
The test is trying to log in but Supabase is rejecting the credentials.

Are you using a test Supabase project in CI? Let me check your env vars...

I see process.env.NEXT_PUBLIC_SUPABASE_URL in the test but it's not set in CI.

I'll add to your .github/workflows/playwright.yml:

env:
  NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.TEST_SUPABASE_URL }}
  NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.TEST_SUPABASE_ANON_KEY }}

And I'll create a fixture that ensures the test user exists before each test.
```

## Using Playwright's Debug Tools (Through Claude)

You don't need to learn these tools, but Claude Code uses them. Here's what happens behind the scenes:

### Trace Files

When test fails in CI, you download the trace file.

**You:** "Here's the trace file from CI" (attach file)

**Claude Code:**
```
Let me analyze the trace...

[Claude examines the trace viewer output]

I can see from the screenshots that the "Create" button is present
but it's disabled. Looking at the network tab, the API call to fetch
user permissions is still pending.

The test needs to wait for permissions to load before clicking:

await page.waitForResponse(resp => resp.url().includes('/api/permissions'));
await page.getByRole('button', { name: 'Create' }).click();

This is why it works locally (fast) but fails in CI (slower network).
```

You never opened Trace Viewer yourself. Claude did it for you.

### Screenshots

Tests automatically take screenshots on failure.

**You:** "Test failed, here's the screenshot" (attach image)

**Claude Code:**
```
Looking at the screenshot, I can see the modal is showing
but the form fields are empty. The test is trying to submit
before the form is populated with default values.

The issue is the form loads asynchronously. I'll add a wait:

await expect(page.getByLabel('Title')).toHaveValue('');  // Wait for field
await page.getByLabel('Title').fill('My Task');

This ensures the form is ready before we interact with it.
```

### Debug Mode

**Claude Code might ask:** "Can you run this test with --debug and tell me what you see?"

{lang=bash}
```
npx playwright test tasks/create.spec.ts --debug
```

Test pauses at each step. You take a screenshot or note what you see.

**You:** "It paused at the click action. The button exists but nothing happens when I click it."

**Claude Code:**
```
The button exists but clicking does nothing - this is usually
a z-index issue or the button is covered by another element.

Looking at your CSS, I see the modal backdrop has z-index: 50
and the button has z-index: 10. The button is being covered.

Let me update the test to click through to the button:

await page.getByRole('button', { name: 'Create' }).click({ force: true });

Or better, I'll fix your CSS so the button isn't covered.
```

## Debugging Real-Time Features

**You:** "Test for real-time updates is failing. One user creates a task but the other user doesn't see it."

**Claude Code:**
```
Real-time test failures are usually WebSocket/subscription issues.

Let me check if your test waits for the subscription to be ready:

[Examines test]

I see you're opening the second page and immediately expecting the update.
The subscription hasn't connected yet.

I'll add a wait for the subscription:

const page2 = await context.newPage();
await page2.goto('/dashboard');

// Wait for subscription to connect
await page2.waitForResponse(resp =>
  resp.url().includes('realtime') && resp.status() === 101
);

// Now the subscription is ready, create task in page1
await page1.getByRole('button', { name: 'New Task' }).click();
...

// page2 should now see the update
await expect(page2.getByText('New Task')).toBeVisible();
```

## When Claude Asks for More Info

Sometimes Claude needs additional context:

**Claude Code:** "I need to see the component code to understand why the selector isn't working. Can you show me the task creation modal?"

**You:** (paste component code or point to file)

**Claude Code:**
```
Ah, I see the issue. Your button uses a custom <Button> component
that doesn't expose the role="button" attribute.

The test should use this selector instead:

await page.getByTestId('create-task-button').click();

Or I can update your Button component to include role="button".
Which would you prefer?
```

You make the decision, Claude implements it.

## Preventing Future Failures

After fixing a test, Claude Code learns:

**Claude Code:**
```
I've fixed this test, and I noticed this is the third time we've had
timing issues with form submissions.

I'm going to create a helper function that all tests can use:

// e2e/helpers/forms.ts
export async function submitForm(page: Page, buttonName: string) {
  await page.waitForLoadState('networkidle');
  await page.getByRole('button', { name: buttonName }).click();
  await page.waitForURL(url => !url.includes('?'));
}

Now all tests can use:
await submitForm(page, 'Create');

This prevents future timing issues.
```

You didn't ask for this. Claude Code proactively improves the test suite.

## CI Debugging Workflow

When test fails in CI:

### 1. Check GitHub Actions Log

**You:** "Test failed in CI. Here's the log" (copy/paste)

**Claude Code:** "I see the error. Let me fix the test."

### 2. Download Artifacts (If Needed)

GitHub Actions uploads trace files when tests fail.

**You:** "Here's the trace artifact from CI" (download and share)

**Claude Code:** "Analyzing the trace... I found the issue..."

### 3. Fix and Re-Run

**Claude Code:** "I've pushed a fix to your branch. The CI should pass now."

You check GitHub - test passes ✅

## The Learning Curve (There Isn't One)

**Week 1:**
- You: "Test failed"
- Claude: "Here's the fix"
- You: "Thanks"

**Week 10:**
- You: "Test failed with element not found"
- Claude: "Here's the fix"
- You: "Wait, is this the same issue we had before?"
- Claude: "Yes, similar pattern. Want me to create a helper to prevent this?"

**Week 50:**
- You: "Test failing, probably timing issue"
- Claude: "Yep, added proper wait"
- You: "Thanks, knew it"

You learn patterns by osmosis, not by studying.

## Summary: The Debugging Partnership

**Your job:**
- Run tests
- Report failures
- Make decisions ("fix test" vs "fix UI")
- Verify fixes work

**Claude Code's job:**
- Analyze errors
- Examine traces/screenshots
- Identify root causes
- Generate fixes
- Explain what went wrong
- Prevent similar issues

**Result:** Tests stay passing with minimal effort from you.

## Why This Works

Traditional E2E testing requires you to be expert in:
- Playwright API
- Browser DevTools
- Async/await patterns
- Selector strategies
- Debugging techniques

Vibe coding E2E testing requires you to be expert in:
- Your application's user flows
- Clear communication with Claude Code

That's it.

The debugging tools (Trace Viewer, Inspector, screenshots) still exist and work great. Claude Code uses them. You don't have to.

**Focus your expertise where it matters:** Understanding your users and shipping features that work.

T> **The Ultimate Debug Tool: Natural Language**
T>
T> The most powerful debugging tool isn't Trace Viewer or Chrome DevTools. It's being able to say "This test is flaky" and having Claude Code fix it. Natural language is the user interface.
