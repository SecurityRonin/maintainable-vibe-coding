# E2E Testing Patterns

Now that Playwright is set up, let's learn patterns for writing maintainable, reliable E2E tests.

## The Page Object Model

**Problem:** Repeating selectors across tests makes them brittle.

**Solution:** Page Object Model encapsulates page structure.

**Without Page Objects:**

{lang=typescript}
```
test('create task', async ({ page }) => {
  await page.goto('/dashboard');
  await page.getByRole('button', { name: 'New Task' }).click();
  await page.getByLabel('Title').fill('My Task');
  await page.getByLabel('Description').fill('Do something');
  await page.getByRole('button', { name: 'Create' }).click();
});

test('edit task', async ({ page }) => {
  await page.goto('/dashboard');
  // Duplicated selectors! If UI changes, update everywhere
  await page.getByRole('button', { name: 'Edit Task' }).click();
  await page.getByLabel('Title').fill('Updated');
});
```

**With Page Objects:**

{lang=typescript}
```
// e2e/pages/DashboardPage.ts
export class DashboardPage {
  constructor(private page: Page) {}

  async goto() {
    await this.page.goto('/dashboard');
  }

  async clickNewTask() {
    await this.page.getByRole('button', { name: 'New Task' }).click();
  }

  async fillTaskForm(title: string, description: string) {
    await this.page.getByLabel('Title').fill(title);
    await this.page.getByLabel('Description').fill(description);
  }

  async submitTaskForm() {
    await this.page.getByRole('button', { name: 'Create' }).click();
  }

  async expectTaskVisible(title: string) {
    await expect(this.page.getByText(title)).toBeVisible();
  }
}
```

**Using Page Objects:**

{lang=typescript}
```
test('create task', async ({ page }) => {
  const dashboard = new DashboardPage(page);

  await dashboard.goto();
  await dashboard.clickNewTask();
  await dashboard.fillTaskForm('My Task', 'Do something');
  await dashboard.submitTaskForm();
  await dashboard.expectTaskVisible('My Task');
});
```

**Benefits:**
- ✅ Change UI selectors in one place
- ✅ Reusable across tests
- ✅ Self-documenting test code
- ✅ Easier to refactor

## Test Isolation

**Problem:** Tests that depend on each other are flaky and hard to debug.

**Solution:** Each test should be completely independent.

**Bad: Tests depend on order**

{lang=typescript}
```
test('create task', async ({ page }) => {
  // Creates task
});

test('edit task', async ({ page }) => {
  // Assumes task from previous test exists! FLAKY!
});
```

**Good: Each test sets up its own data**

{lang=typescript}
```
test('edit task', async ({ page }) => {
  // Create test task first
  const taskId = await createTestTask({
    title: 'Original Title'
  });

  // Now test editing
  await page.goto(`/tasks/${taskId}/edit`);
  await page.getByLabel('Title').fill('New Title');
  await page.getByRole('button', { name: 'Save' }).click();

  await expect(page.getByText('New Title')).toBeVisible();
});
```

## Fixtures for Common Setup

**Problem:** Every test needs to log in and set up data.

**Solution:** Create reusable fixtures.

{lang=typescript}
```
// e2e/fixtures.ts
import { test as base } from '@playwright/test';
import { DashboardPage } from './pages/DashboardPage';

type Fixtures = {
  authenticatedPage: Page;
  dashboard: DashboardPage;
};

export const test = base.extend<Fixtures>({
  // Fixture: Authenticated page
  authenticatedPage: async ({ page }, use) => {
    // Log in before each test
    await page.goto('/login');
    await page.getByLabel('Email').fill('test@example.com');
    await page.getByLabel('Password').fill('password123');
    await page.getByRole('button', { name: 'Sign In' }).click();
    await page.waitForURL('/dashboard');

    // Give test access to authenticated page
    await use(page);

    // Cleanup: logout after test
    await page.getByRole('button', { name: 'Logout' }).click();
  },

  // Fixture: Dashboard page object
  dashboard: async ({ authenticatedPage }, use) => {
    const dashboard = new DashboardPage(authenticatedPage);
    await use(dashboard);
  },
});
```

**Using fixtures:**

{lang=typescript}
```
import { test, expect } from './fixtures';

test('create task', async ({ dashboard }) => {
  // Already logged in! No setup needed
  await dashboard.clickNewTask();
  await dashboard.fillTaskForm('My Task', 'Description');
  await dashboard.submitTaskForm();
  await dashboard.expectTaskVisible('My Task');
});
```

## Testing Authentication

**Email/Password login:**

{lang=typescript}
```
test('login with valid credentials', async ({ page }) => {
  await page.goto('/login');
  await page.getByLabel('Email').fill('user@example.com');
  await page.getByLabel('Password').fill('password123');
  await page.getByRole('button', { name: 'Sign In' }).click();

  await expect(page).toHaveURL('/dashboard');
  await expect(page.getByText('Welcome back')).toBeVisible();
});

test('login with invalid password', async ({ page }) => {
  await page.goto('/login');
  await page.getByLabel('Email').fill('user@example.com');
  await page.getByLabel('Password').fill('wrong');
  await page.getByRole('button', { name: 'Sign In' }).click();

  // Should show error
  await expect(page.getByText('Invalid credentials')).toBeVisible();

  // Should NOT redirect
  await expect(page).toHaveURL('/login');
});
```

**OAuth login (tricky!):**

{lang=typescript}
```
test('login with Google', async ({ page, context }) => {
  await page.goto('/login');

  // Click Google login button
  const [popup] = await Promise.all([
    context.waitForEvent('page'), // Wait for OAuth popup
    page.getByRole('button', { name: 'Continue with Google' }).click()
  ]);

  // Fill in Google login form (in popup)
  await popup.waitForLoadState();
  await popup.getByLabel('Email').fill('test@gmail.com');
  await popup.getByLabel('Password').fill('password');
  await popup.getByRole('button', { name: 'Sign in' }).click();

  // Wait for redirect back to app
  await page.waitForURL('/dashboard');
  await expect(page.getByText('Welcome')).toBeVisible();
});
```

**Pro tip:** Mock OAuth in tests for speed:

{lang=typescript}
```
test('login with Google (mocked)', async ({ page }) => {
  // Intercept OAuth callback
  await page.route('**/auth/callback*', route => {
    route.fulfill({
      status: 302,
      headers: { Location: '/dashboard?token=fake-test-token' }
    });
  });

  await page.goto('/login');
  await page.getByRole('button', { name: 'Continue with Google' }).click();

  await expect(page).toHaveURL(/\/dashboard/);
});
```

## Testing Real-Time Features

**Problem:** Real-time features (WebSockets, Supabase subscriptions) need special handling.

**Solution:** Use Playwright's `waitFor` helpers.

{lang=typescript}
```
test('real-time task updates', async ({ page, context }) => {
  // Open two browser tabs
  const page1 = page;
  const page2 = await context.newPage();

  // Both navigate to dashboard
  await page1.goto('/dashboard');
  await page2.goto('/dashboard');

  // User 1 creates task
  await page1.getByRole('button', { name: 'New Task' }).click();
  await page1.getByLabel('Title').fill('Real-time Task');
  await page1.getByRole('button', { name: 'Create' }).click();

  // User 2 should see it appear (real-time!)
  await expect(page2.getByText('Real-time Task')).toBeVisible();
});
```

## Testing Drag and Drop

**Problem:** Drag-and-drop requires mouse events.

**Solution:** Use Playwright's drag-and-drop API.

{lang=typescript}
```
test('drag task to different column', async ({ page }) => {
  await page.goto('/kanban');

  const task = page.getByText('My Task');
  const targetColumn = page.getByTestId('column-in-progress');

  // Drag task to target column
  await task.dragTo(targetColumn);

  // Verify task moved
  await expect(targetColumn.getByText('My Task')).toBeVisible();
});
```

## Handling Async Operations

**Problem:** Tests fail because they run faster than the app.

**Solution:** Playwright auto-waits, but use explicit waits when needed.

**Auto-waiting (preferred):**

{lang=typescript}
```
test('create task with API call', async ({ page }) => {
  await page.goto('/dashboard');
  await page.getByRole('button', { name: 'New Task' }).click();
  await page.getByLabel('Title').fill('API Task');
  await page.getByRole('button', { name: 'Create' }).click();

  // Playwright automatically waits for element to appear
  await expect(page.getByText('API Task')).toBeVisible();
  // No manual waiting needed!
});
```

**Explicit waits (when needed):**

{lang=typescript}
```
test('wait for loading to finish', async ({ page }) => {
  await page.goto('/dashboard');

  // Wait for loading spinner to disappear
  await page.waitForSelector('[data-testid="loading"]', {
    state: 'hidden'
  });

  // Now interact with loaded content
  await page.getByText('Dashboard').click();
});
```

**Wait for network:**

{lang=typescript}
```
test('wait for API response', async ({ page }) => {
  await page.goto('/dashboard');

  // Wait for specific API call
  await page.waitForResponse(
    response => response.url().includes('/api/tasks') &&
                response.status() === 200
  );

  // API finished, now assert
  await expect(page.getByText('Tasks loaded')).toBeVisible();
});
```

## Testing Forms

**Complex forms with validation:**

{lang=typescript}
```
test('form validation', async ({ page }) => {
  await page.goto('/tasks/new');

  // Submit empty form
  await page.getByRole('button', { name: 'Create' }).click();

  // Should show validation errors
  await expect(page.getByText('Title is required')).toBeVisible();

  // Fill invalid data
  await page.getByLabel('Due Date').fill('invalid-date');
  await page.getByRole('button', { name: 'Create' }).click();

  await expect(page.getByText('Invalid date format')).toBeVisible();

  // Fix errors and submit
  await page.getByLabel('Title').fill('Valid Task');
  await page.getByLabel('Due Date').fill('2025-12-31');
  await page.getByRole('button', { name: 'Create' }).click();

  // Should succeed
  await expect(page).toHaveURL('/dashboard');
  await expect(page.getByText('Task created')).toBeVisible();
});
```

## When to Use E2E vs Unit Tests

**E2E tests:**
- ✅ Critical user journeys
- ✅ Features with UI interactions
- ✅ Integration between frontend + backend + database
- ✅ Real browser behavior matters

**Unit tests:**
- ✅ Business logic functions
- ✅ Edge cases and error handling
- ✅ Utility functions
- ✅ Fast feedback during development

**Example split:**

```
TaskFlow test coverage:
- 5 E2E tests (critical flows)
  - Signup → Create task → Complete task
  - Login → Edit task → Logout
  - Drag task between columns
  - Real-time collaboration
  - Payment flow (if applicable)

- 50+ unit tests (business logic)
  - Task validation
  - Date formatting
  - Filter logic
  - Permission checks
```

**Rule: 70% unit tests, 30% E2E tests**

## Common Pitfalls

**❌ Testing implementation details:**

{lang=typescript}
```
// Bad: Relies on class names
await page.locator('.btn-primary').click();

// Good: Uses accessible names
await page.getByRole('button', { name: 'Create Task' }).click();
```

**❌ Flaky waits:**

{lang=typescript}
```
// Bad: Arbitrary timeout
await page.waitForTimeout(3000);

// Good: Wait for specific condition
await page.waitForSelector('[data-testid="task-list"]');
```

**❌ Too many E2E tests:**

```
// Bad: E2E test for every function
test('formats date correctly', ...)  // Should be unit test!

// Good: E2E for user journeys only
test('user can create and edit task', ...)
```

## Next Steps

You've learned patterns for maintainable E2E tests. Next, we'll cover Playwright's powerful auto-debugging tools.

T> **Claude Code + Playwright**
T>
T> Use Claude Code to write E2E tests! Describe the user flow in natural language, and Claude Code generates the Playwright test. Example: "Write an E2E test for login flow with email and password"
