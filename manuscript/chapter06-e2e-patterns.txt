# Understanding E2E Test Patterns

Claude Code writes your Playwright tests, but it's useful to understand the patterns it uses. Not so you can write them yourself, but so you can:

1. Review tests Claude Code generates
2. Request specific patterns
3. Understand why tests are structured a certain way
4. Spot when something looks wrong

Think of this as "reading comprehension" not "writing skills."

## Pattern 1: Page Objects

**What you'll see Claude Code create:**

{lang=typescript}
```
// e2e/pages/DashboardPage.ts
export class DashboardPage {
  constructor(private page: Page) {}

  async goto() {
    await this.page.goto('/dashboard');
  }

  async createTask(title: string) {
    await this.page.getByRole('button', { name: 'New Task' }).click();
    await this.page.getByLabel('Title').fill(title);
    await this.page.getByRole('button', { name: 'Create' }).click();
  }

  async expectTaskVisible(title: string) {
    await expect(this.page.getByText(title)).toBeVisible();
  }
}
```

**Why Claude does this:**
- Changes to UI selectors only need updating in one place
- Tests read like English: `dashboard.createTask('My Task')`
- Reusable across multiple tests

**What you do:**
- Review: "Does this match my UI?"
- Request: "Use Page Object pattern for dashboard tests"
- Trust: Claude Code knows when to use this pattern

## Pattern 2: Test Fixtures

**What you'll see:**

{lang=typescript}
```
// e2e/fixtures.ts
export const test = base.extend({
  authenticatedPage: async ({ page }, use) => {
    // Logs in before each test
    await page.goto('/login');
    await page.getByLabel('Email').fill('test@example.com');
    await page.getByLabel('Password').fill('password');
    await page.getByRole('button', { name: 'Sign In' }).click();
    await page.waitForURL('/dashboard');

    await use(page);

    // Logs out after test
    await page.getByRole('button', { name: 'Logout' }).click();
  },
});
```

**Why Claude does this:**
- Every test that needs authentication uses this fixture
- No repeated login code in every test
- Automatic cleanup after tests

**What you do:**
- Review: "Is this the right login flow?"
- Request: "Add fixture for authenticated admin user"
- Appreciate: Tests are cleaner because of this

## Pattern 3: Test Isolation

**What you'll see:**

{lang=typescript}
```
test('edit task', async ({ page }) => {
  // Each test creates its own test data
  const taskId = await createTestTask({ title: 'Original' });

  await page.goto(`/tasks/${taskId}/edit`);
  await page.getByLabel('Title').fill('Updated');
  await page.getByRole('button', { name: 'Save' }).click();

  await expect(page.getByText('Updated')).toBeVisible();
});
```

**Why Claude does this:**
- Tests don't depend on each other
- Can run in any order
- Parallel execution works
- Easier to debug

**What you do:**
- Notice: Each test stands alone
- Request: "Make sure tests don't depend on each other"
- Run: Tests in parallel with `--workers=4`

## Pattern 4: Waiting Strategies

**What you'll see:**

{lang=typescript}
```
// Claude waits for API responses
await page.waitForResponse(resp =>
  resp.url().includes('/api/tasks') &&
  resp.status() === 200
);

// Claude waits for elements
await expect(page.getByText('Loading...')).not.toBeVisible();

// Claude doesn't use arbitrary timeouts
// ❌ await page.waitForTimeout(3000);
```

**Why Claude does this:**
- Tests are reliable, not flaky
- Fast when possible, patient when needed
- No guessing at timeouts

**What you do:**
- If test is flaky: "Claude, this test is flaky, fix the waiting"
- Trust: Claude picks the right wait strategy
- Learn: Read the waits Claude adds to understand timing

## Pattern 5: Testing Real-Time Features

**What you'll see:**

{lang=typescript}
```
test('real-time updates', async ({ page, context }) => {
  const page1 = page;
  const page2 = await context.newPage();

  // Both pages open dashboard
  await page1.goto('/dashboard');
  await page2.goto('/dashboard');

  // User 1 creates task
  await page1.getByRole('button', { name: 'New Task' }).click();
  await page1.getByLabel('Title').fill('Real-time Task');
  await page1.getByRole('button', { name: 'Create' }).click();

  // User 2 sees it immediately (real-time!)
  await expect(page2.getByText('Real-time Task')).toBeVisible();
});
```

**Why Claude does this:**
- Opens multiple browser contexts
- Simulates multiple users
- Verifies WebSocket/Supabase subscriptions work

**What you do:**
- Request: "Test that two users see changes in real-time"
- Review: "Yes, this tests what I need"
- Ship: Confidence in real-time features

## Pattern 6: Form Validation Testing

**What you'll see:**

{lang=typescript}
```
test('form validation', async ({ page }) => {
  await page.goto('/tasks/new');

  // Submit empty form
  await page.getByRole('button', { name: 'Create' }).click();

  // Expect validation errors
  await expect(page.getByText('Title is required')).toBeVisible();

  // Fill valid data
  await page.getByLabel('Title').fill('Valid Task');
  await page.getByRole('button', { name: 'Create' }).click();

  // Success
  await expect(page).toHaveURL('/dashboard');
});
```

**Why Claude does this:**
- Tests both error and success states
- Verifies user sees helpful error messages
- Confirms form actually submits when valid

**What you do:**
- Request: "Test form validation for task creation"
- Review: "Does this cover all validation rules?"
- Add: "Also test invalid date format"

## Pattern 7: Authentication Flows

**What you'll see for email/password:**

{lang=typescript}
```
test('login with valid credentials', async ({ page }) => {
  await page.goto('/login');
  await page.getByLabel('Email').fill('user@example.com');
  await page.getByLabel('Password').fill('password123');
  await page.getByRole('button', { name: 'Sign In' }).click();

  await expect(page).toHaveURL('/dashboard');
});

test('login with invalid password', async ({ page }) => {
  await page.goto('/login');
  await page.getByLabel('Email').fill('user@example.com');
  await page.getByLabel('Password').fill('wrong');
  await page.getByRole('button', { name: 'Sign In' }).click();

  await expect(page.getByText('Invalid credentials')).toBeVisible();
  await expect(page).toHaveURL('/login'); // Still on login page
});
```

**What you'll see for OAuth:**

{lang=typescript}
```
test('login with Google', async ({ page }) => {
  // Claude mocks OAuth in tests for speed
  await page.route('**/auth/callback*', route => {
    route.fulfill({
      status: 302,
      headers: { Location: '/dashboard?token=test-token' }
    });
  });

  await page.goto('/login');
  await page.getByRole('button', { name: 'Continue with Google' }).click();

  await expect(page).toHaveURL(/\/dashboard/);
});
```

**Why Claude does this:**
- OAuth tests run fast (no real Google popup)
- Tests both success and error paths
- Focuses on YOUR app's behavior

**What you do:**
- Request: "Test Google OAuth login"
- Review: "Mocking is fine for tests"
- Ship: Confidence in auth flows

## How to Request Patterns

You don't need to know the implementation. Just describe what you want:

**Instead of:**
"Create a Page Object Model with getters for dashboard elements and async methods for user interactions"

**Say:**
"Organize the dashboard tests so selectors aren't repeated everywhere"

**Claude Code will:**
- Recognize you want Page Objects
- Implement the pattern
- Apply it consistently

## When Patterns Don't Match Your App

**You:** "Claude, this test uses `getByRole('button')` but my buttons are styled links. Fix the selectors."

**Claude Code:**
- Updates selectors to match your UI
- Explains why `getByRole` didn't work
- Uses `getByTestId` or `getByText` instead

**You don't need to know Playwright selectors.** Just tell Claude what's wrong.

## Reading Tests Like Documentation

Tests Claude Code writes ARE documentation:

{lang=typescript}
```
test('user creates task with attachments', async ({ page }) => {
  await page.goto('/dashboard');
  await page.getByRole('button', { name: 'New Task' }).click();
  await page.getByLabel('Title').fill('Task with files');

  // Upload attachment
  await page.getByLabel('Attach files').setInputFiles('test-file.pdf');

  await page.getByRole('button', { name: 'Create' }).click();

  // Task shows attachment
  await expect(page.getByText('test-file.pdf')).toBeVisible();
});
```

**Reading this tells you:**
- Tasks can have attachments
- Users click "New Task" to create
- File upload field is labeled "Attach files"
- Created task displays file name

**Better than README:** Tests prove features work.

## Common Test Anti-Patterns

Claude Code avoids these, but know them so you can spot issues:

**❌ Testing implementation details:**
```typescript
// Bad: Tests class names
await page.locator('.btn-primary').click();

// Good: Tests user-visible behavior
await page.getByRole('button', { name: 'Create' }).click();
```

**❌ Arbitrary timeouts:**
```typescript
// Bad: Guessing at timing
await page.waitForTimeout(3000);

// Good: Waiting for specific condition
await page.waitForSelector('[data-testid="task-list"]');
```

**❌ Too many E2E tests:**
```typescript
// Bad: E2E for every function
test('formats date correctly', ...) // This should be unit test!

// Good: E2E for user journeys
test('user creates and edits task', ...)
```

If you see these in Claude Code's tests, say: "This looks like an anti-pattern, fix it."

## Summary: You're the Director

Think of E2E testing with Claude Code like directing a movie:

**You (Director):**
- Describe the scene: "User logs in, creates task, logs out"
- Review the result: "Looks good" or "Change this part"
- Approve for shipping: "Run tests, commit"

**Claude Code (Screenwriter + Camera Operator):**
- Writes the script (test code)
- Handles technical details (selectors, waits, fixtures)
- Captures the action (runs tests, generates traces)

You don't need to operate the camera. You need to know what you want to capture.

Next chapter: How Claude Code debugs failing E2E tests for you.

T> **Pattern Recognition Over Memorization**
T>
T> After seeing Claude Code write 50 tests, you'll recognize patterns. That's better than memorizing Playwright API. You'll be able to say "Use the pattern you used in the auth tests" and Claude knows exactly what you mean.
